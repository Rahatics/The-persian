// Background service worker for The Parsian Browser Extension
let websocket = null;
let reconnectAttempts = 0;
const MAX_RECONNECT_ATTEMPTS = 5;
const RECONNECT_DELAY = 3000;

// Error handling and retry mechanisms
const ERROR_RETRY_ATTEMPTS = 3;
const ERROR_RETRY_DELAY = 1000;
let pendingMessages = new Map(); // Store messages that failed to send

// Load the port from the lock file
async function getPortFromLockFile() {
  try {
    // In a real implementation, this would read from the .parsian-lock file
    // created by the VS Code extension
    // For now, we'll use the default port that the server is configured to use
    return 8765;
  } catch (error) {
    console.error('Error reading lock file:', error);
    return 8765; // Default port
  }
}

// Connect to the WebSocket server
async function connectToWebSocket() {
  try {
    const port = await getPortFromLockFile();
    const wsUrl = `ws://127.0.0.1:${port}`;
    
    console.log(`Connecting to WebSocket at ${wsUrl}`);
    
    websocket = new WebSocket(wsUrl);
    
    websocket.onopen = function(event) {
      console.log('Connected to VS Code extension');
      resetConnectionStatus();
      chrome.action.setIcon({path: 'TheParsian-16x16.svg'});
      
      // Send any pending messages
      sendPendingMessages();
    };
    
    websocket.onmessage = function(event) {
      console.log('Received message from VS Code:', event.data);
      handleMessageFromVSCode(event.data);
    };
    
    websocket.onclose = function(event) {
      console.log('WebSocket connection closed');
      handleDisconnection();
    };
    
    websocket.onerror = function(error) {
      console.error('WebSocket error:', error);
      handleDisconnection();
    };
  } catch (error) {
    console.error('Error connecting to WebSocket:', error);
    handleDisconnection();
  }
}

// Send a message with retry mechanism
function sendWithRetry(message, messageId) {
  if (!websocket || websocket.readyState !== WebSocket.OPEN) {
    // Store message for later sending
    pendingMessages.set(messageId, message);
    console.log('WebSocket not connected, message queued:', messageId);
    return false;
  }
  
  try {
    websocket.send(message);
    console.log('Message sent successfully:', messageId);
    return true;
  } catch (error) {
    console.error('Error sending message:', error);
    
    // Store for retry
    pendingMessages.set(messageId, message);
    
    // Retry mechanism
    retrySendMessage(messageId, message, 1);
    return false;
  }
}

// Retry sending a message
async function retrySendMessage(messageId, message, attempt) {
  if (attempt > ERROR_RETRY_ATTEMPTS) {
    console.error(`Failed to send message after ${ERROR_RETRY_ATTEMPTS} attempts:`, messageId);
    pendingMessages.delete(messageId);
    return;
  }
  
  console.log(`Retrying message send (attempt ${attempt}):`, messageId);
  
  // Wait before retrying
  await new Promise(resolve => setTimeout(resolve, ERROR_RETRY_DELAY * attempt));
  
  if (!websocket || websocket.readyState !== WebSocket.OPEN) {
    // Still not connected, retry
    retrySendMessage(messageId, message, attempt + 1);
    return;
  }
  
  try {
    websocket.send(message);
    console.log('Message sent successfully on retry:', messageId);
    pendingMessages.delete(messageId);
  } catch (error) {
    console.error(`Error sending message on retry ${attempt}:`, error);
    retrySendMessage(messageId, message, attempt + 1);
  }
}

// Send pending messages
function sendPendingMessages() {
  if (!websocket || websocket.readyState !== WebSocket.OPEN) {
    return;
  }
  
  console.log(`Sending ${pendingMessages.size} pending messages`);
  
  for (const [messageId, message] of pendingMessages.entries()) {
    try {
      websocket.send(message);
      console.log('Pending message sent:', messageId);
      pendingMessages.delete(messageId);
    } catch (error) {
      console.error('Error sending pending message:', error);
      // Will retry on next connection
    }
  }
}

// Handle disconnection and reconnection logic
function handleDisconnection() {
  chrome.action.setIcon({path: 'TheParsian-16x16.svg'});
  
  if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
    reconnectAttempts++;
    console.log(`Reconnection attempt ${reconnectAttempts} in ${RECONNECT_DELAY}ms`);
    
    setTimeout(() => {
      connectToWebSocket();
    }, RECONNECT_DELAY);
  } else {
    console.log('Max reconnection attempts reached');
    // Show error to user
    chrome.action.setBadgeText({text: 'ERR'});
    chrome.action.setBadgeBackgroundColor({color: '#FF0000'});
  }
}

// Reset connection status
function resetConnectionStatus() {
  reconnectAttempts = 0;
  chrome.action.setBadgeText({text: ''});
}

// Handle messages from VS Code extension
function handleMessageFromVSCode(data) {
  try {
    const message = JSON.parse(data);
    
    // Process the message based on its type
    switch (message.action_type) {
      case 'CODE_SUGGEST':
        handleCodeSuggestion(message);
        break;
      case 'EXPLAIN':
        handleExplanationRequest(message);
        break;
      case 'RUN_COMMAND':
        handleCommandRequest(message);
        break;
      default:
        console.warn('Unknown action type:', message.action_type);
        sendResponse({
          request_id: message.id,
          status: 'error',
          message: 'Unknown action type'
        });
    }
  } catch (error) {
    console.error('Error parsing message:', error);
    // Send error response
    if (websocket && websocket.readyState === WebSocket.OPEN) {
      websocket.send(JSON.stringify({
        status: 'error',
        message: 'Invalid message format'
      }));
    }
  }
}

// Listen for messages from the content script
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('Received message from content script:', request);
  
  switch (request.action) {
    case 'ai_response':
    case 'ai_response_complete':
      // Forward AI responses to VS Code extension
      const response = {
        type: 'ai_response',
        content: request.content,
        codeBlocks: request.codeBlocks,
        isComplete: request.action === 'ai_response_complete'
      };
      const responseId = 'response_' + Date.now();
      sendWithRetry(JSON.stringify(response), responseId);
      sendResponse({ success: true });
      break;
    
    case 'rate_limit_detected':
      // Handle rate limiting
      console.log('Rate limit detected at:', new Date(request.timestamp));
      
      // Forward to VS Code extension
      const rateLimitId = 'rate_limit_' + Date.now();
      sendWithRetry(JSON.stringify({
        type: 'rate_limit_detected',
        timestamp: request.timestamp
      }), rateLimitId);
      sendResponse({ success: true });
      break;
      
    case 'captcha_detected':
      // Handle CAPTCHA detection
      console.log('CAPTCHA detected at:', new Date(request.timestamp));
      
      // Forward to VS Code extension
      const captchaId = 'captcha_' + Date.now();
      sendWithRetry(JSON.stringify({
        type: 'captcha_detected',
        timestamp: request.timestamp
      }), captchaId);
      sendResponse({ success: true });
      break;
    
    default:
      sendResponse({ success: false, error: 'Unknown action' });
  }
  
  return true; // Keep the message channel open for async response
});

// Handle code suggestion requests
function handleCodeSuggestion(message) {
  console.log('Handling code suggestion request:', message);
  
  // In a real implementation, this would interact with the AI service
  // For now, we'll send a placeholder response
  const response = {
    request_id: message.id,
    status: 'success',
    data: {
      content: `// Code suggestion for: ${message.user_query}\nfunction placeholder() {\n  console.log('This is a placeholder response');\n}`,
      language: 'javascript'
    },
    security: {
      requires_confirmation: false,
      confidence: 'high'
    }
  };
  
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify(response));
  }
}

// Handle explanation requests
function handleExplanationRequest(message) {
  console.log('Handling explanation request:', message);
  
  // In a real implementation, this would interact with the AI service
  // For now, we'll send a placeholder response
  const response = {
    request_id: message.id,
    status: 'success',
    data: {
      content: `Explanation for: ${message.user_query}\n\nThis is a placeholder explanation.`,
      language: 'text'
    },
    security: {
      requires_confirmation: false,
      confidence: 'high'
    }
  };
  
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify(response));
  }
}

// Handle command requests
function handleCommandRequest(message) {
  console.log('Handling command request:', message);
  
  // In a real implementation, this would interact with the AI service
  // For now, we'll send a placeholder response
  const response = {
    request_id: message.id,
    status: 'success',
    data: {
      content: `Command result for: ${message.user_query}\n\n$ placeholder-command-result`,
      language: 'bash'
    },
    security: {
      requires_confirmation: true,
      confidence: 'medium'
    }
  };
  
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify(response));
  }
}

// Send a response back to VS Code
function sendResponse(response) {
  if (websocket && websocket.readyState === WebSocket.OPEN) {
    websocket.send(JSON.stringify(response));
  }
}

// Initialize the extension
chrome.runtime.onStartup.addListener(() => {
  console.log('The Parsian Browser Extension started');
  connectToWebSocket();
});

// Also connect when the extension is installed/updated
chrome.runtime.onInstalled.addListener(() => {
  console.log('The Parsian Browser Extension installed/updated');
  connectToWebSocket();
});

// Attempt to connect immediately when the background script loads
connectToWebSocket();